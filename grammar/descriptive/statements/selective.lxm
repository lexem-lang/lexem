
#------------------------#
#- Lexem grammar v0.1.0 -#
#------------------------#
#- Description:
#-    Selective statements of the lexem's descriptive core.
#------------------------#

let {sml, ..gen} = import("generics")
let fn_exp = import("functional/expressions")
let exp_stmt = import("../statements")
let {destructuring as var_destructuring} = import("./var_declarations")

pub! exp selective {
    |> gen.keyword("match")

    onBack {
        log.error("The selective statement requires an expression for its condition.")
    }
    |> sml* condition:fn_exp.expression

    onBack {
        log.error("The selective statement requires here the open bracket '{'.")
    }
    |> sml* "{"
    |? "'" tag:gen.identifier

    for *+ {
        |> sml* cases:selective_case
    }
    
    onBack {
        log.error("The selective statement requires here the close bracket '}'.")
    }
    |> sml* "}"
}

exp case {
    |> (patterns:pattern /infix: sml* "," sml*)+

    onBack {
        log.error("The selective case requires a block statement ({}) for its body.")
    }
    |> sml* code:exp_stmt.block
}

exp pattern {
    | "any!" set_props![any]
    | {
        | gen.keyword("var") set_props![- isConst]
        | gen.keyword("let") set_props![isConst]

        onBack {
            log.error("An identifier or destructuring is required for the var declaration pattern.")
        }
        | sml* name: gen.identifier
        | sml* destructuring: destructuring
    }
    | value:fn_exp.expression

    |? sml* conditional:pattern_conditional
}

exp pattern_conditional {
    | gen.keyword("if") set_props![if]
    | gen.keyword("unless") set_props![- if]

    onBack {
        log.error("The conditional pattern requires an expression for its condition.")
    }
    |> sml* condition:fn_exp.expression
}

