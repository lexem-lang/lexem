
--------------------------
-- Lexem grammar v0.1.1 --
--------------------------
-- Description:
--    Expressions of the functional core.
--------------------------

let (ws, identifier_dynamic, check_keyword, identifier) = import("root:commons")
let literals = import("root:literals")
let fn_stmt = import("statements")
let (pattern) = import("descriptive/expression")
let (property_style_object_block) = import("root:literals/objects")


------------------------
--  Generic Elements  --
------------------------

pub! exp expression {
    | {
        |> left_expression ws? assign_operator ws?

        onBack {
            log.error("A right expression was expected after the assign operator.")
        }

        | expression
        | right_expression
    }
    | right_expression
}

pub! exp assign {
    |> left_expression ws? assign_operator

	onBack {
        log.error("A right expression was expected after the assign operator.")
    }

    |> ws? expression
}

pub! exp left_expression[- capture] {
    | access
}

pub! exp right_expression[- capture] {
    |> logic_expression
}

exp prefix_expression[- capture] {
    |? prefix_operator set_props![capture] {
        onBack {
            log.error("An infix expression was expected after the prefix operator.")
        }
    }
    | access
    | global.lexem.block
}

exp literal[- capture] {
    | literals.null
    | literals.logic
    | literals.number
    | literals.string
    | literals.interval
    | literals.bitlist
    | literals.list
    | literals.set
    | literals.object
    | literals.map
    | literals.function
}

exp access {
    | literal
    | macro
    | identifier

    for *+ {
        | access_explicit_member
        | access_indexer
        | function_call
    }
}

exp access_explicit_member {
    |> "."

	onBack {
        log.error("An explicit member expression requires an identifier after the '.' symbol.")
    }

    |> identifier_dynamic
}

exp access_indexer {
    |> "["

	onBack {
        log.error("An index requires an expression after the open square bracket '[' symbol.")
    }

    |> ws? expression

    onBack {
        log.error("Incorrect indexer. The close square bracket ']' is require.")
    }

    |> ws? "]"
}

exp function_call {
	|> "(" ws?

    |? function_call_first_element {
        for *+ {
            |> ws? "," ws?
            | function_call_middle_element
        }
    }

    -- Spread element
    |? ws? "," ws? ".." spread:fn_exp.expression
    |? ws? ","  -- trailing comma

	onBack {
		log.error("Incorrect function call. The close parenthesis ')' is required.")
	}

	|> ws? ")"
	|? function_call_expression_properties
}

exp function_call_first_element {
	| function_call_element
    | fn_exp.expression
}

exp function_call_middle_element {
	|> identifier_dynamic ws? ":"

    onBack {
        log.error("Incorrect function call. After the relation symbol ':' it is require the value of the argument.")
    }

    |> ws? fn_exp.expression
}

exp function_call_expression_properties {
    |> ":"

    onBack {
        log.error("An open square bracket was expected after the token ':'.")
    }

    |> property_style_object_block
}

exp macro[- capture] {
    | "logic_line!"
    | "line!"
    | "file!"
    | "directory!"
    | "file_content!"
    | macro_check_props
    | macro_file_content
}

pub! exp macro_check_props {
	|> "check_props!" object:property_style_object_block
}

pub! exp macro_backtrack {
	|> "backtrack!" function_call?
}

--------------------------
--  Binary expressions  --
--------------------------

exp multiplicative_expression[- capture] {
    repeat i for *+ do {
        if i > 0 {
           |? ws?
           |> (operator[capture]: "//" | [*/%]) operator_end
           |? ws?
           set_props![capture]
        }
        |> values:prefix_expression
    }
}

exp additive_expression[- capture] {
    repeat i for *+ do {
        if i > 0 {
           |? ws?
           |> (operator[capture]: [+-]) operator_end
           |? ws?
           set_props![capture]
        }
        |> values:multiplicative_expression
    }
}

exp shift_expression[- capture] {
    repeat i for *+ do {
        if i > 0 {
           |? ws?
           |> (operator[capture]: "<" [</] | [/>] ">") operator_end
           |? ws?
           set_props![capture]
        }
        |> values:additive_expression
    }
}

exp logic_expression[- capture] {
    repeat i for *+ do {
        if i > 0 {
           |? ws?
           |> (operator[capture]: [&|^]) operator_end
           |? ws?
           set_props![capture]
        }
        |> values:shift_expression
    }
}

exp relational_expression[- capture] {
    repeat i for *+ do {
        if i > 0 {
           |? ws?
           |> (operator[capture]: "==""="? | "!=""="? | "<""="? | ">""="?) operator_end
           |? ws?
           set_props![capture]
        }
        |> values:logic_expression
    }
}

exp conditional_expression[- capture] {
    repeat i for *+ do {
        if i > 0 {
           |? ws?
           |> (operator[capture]: gen.keyword("and") | gen.keyword("or") | gen.keyword("xor"))
           |? ws?
           set_props![capture]
        }
        |> values:relational_expression
    }
}



-----------------
--  Operators  --
-----------------

exp prefix_operator {
    |> [-+~!]
    |> operator_end
}

exp assign_operator {
    |? (operator[property]: {
        | "//"
        | "<" [</]
        | [/>] ">"
        | [*/%+-&|^]
        | "and"
        | "or"
        | "xor"
    })
    |> "=" operator_end
}



--------------
--  Others  --
--------------

exp operator_end[- capture children consume] {
    |> ![~!*/%+-&|^<>=]
}

