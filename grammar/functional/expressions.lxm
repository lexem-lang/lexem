
#------------------------#
#- Lexem grammar v0.1.0 -#
#------------------------#
#- Description:
#-    Expressions of the lexem's functional core.
#------------------------#

let {s, ssl, sml, ..gen} = import("generics")
let literals = import("literals")
let fn_stmt = import("./statements")
let {pattern} = import("descriptive/expression")
let {property_style_object} = import("literals/objects")


#----------------------#
#-  Generic Elements  -#
#----------------------#

pub! exp expression {
    | {
        |> left:left_expression sml* operator:assign_operator sml*
        
        onback {
            log.error("A right expression was expected after the assign operator.")
        }
        | right:expression
        | right:right_expression
    }
    | right:right_expression
}

pub! exp assign {
    |> left:left_expression
    
    onback {
        log.error("An assign operator was expected after the left expression.")
    }
    |> sml* operator:assign_operator

	onback {
        log.error("A right expression was expected after the assign operator.")
    }
    |> sml* right:right_expression
}

pub! exp left_expression(props![- capture]) {
    | access
}

pub! exp right_expression(props![- capture]) {
    |> logic_expression
}

exp prefix_expression(props![- capture]) {
    |? prefix_operator operator_end props![capture]
        onback {
            log.error("An infix expression was expected after the prefix operator.")
        }
    | access
    | literal
    | macro
    | fn_stmt.block
}

exp literal(props![- capture]) {
    | literals.null
    | literals.logic
    | literals.number
    | literals.string
    | literals.interval
    | literals.bitlist
    | literals.list
    | literals.set
    | literals.object
    | literals.map
    | literals.function
    | literals.expression
}

exp access {
    |> variable:gen.identifier

    for *+ {
        | modifiers:access_explicit_member
        | modifiers:access_indexer
        | modifiers:function_call
    }
}

exp access_explicit_member {
    set_props![- isOptional]
    |> ("?" set_props![isOptional])? "."

	onback {
        log.error("An explicit member expression requires an indentifier after the '.' symbol.")
    }

    | gen.identifier
    | gen.escaped_expression
    | literals.string
}

exp access_indexer {
    set_props![- isOptional]
    |> ("?" set_props![isOptional])? "["

	onback {
        log.error("An explicit member expression requires an indentifier after the '.' symbol.")
    }
    |> sml* value:expression

    onback {
        log.error("Incorrect indexer. The close square bracket ']' is require.")
    }
    |> sml* "]"
}

exp function_call {
	|> "(" sml*
    
    |? elements:function_call_first_element {
        for + {
            |> sml* "," sml*
            | elements:function_call_simplification
            | elements:function_call_middle_element
        }
    }

    #- Spread element
    |? sml* "," sml* ".." spreaded:fn_exp.expression
    |? sml* "," #- trailing comma

	onback {
		log.error("Incorrect function call. The close parenthesis ')' is required.")
	}
	|> sml* ")"
}

exp function_call_first_element(props![- capture]) {
	| key:function_call_element
    | key:fn_exp.expression
}

exp function_call_middle_element {
	| key:gen.identifier
    | key:gen.escaped_expression
    | key:literals.string
	|> sml* ":"

    onback {
        log.error("Incorrect function call. After the relation symbol ':' it is require the value of the argument.")
    }
    |> sml* value:fn_exp.expression
}

exp function_call_simplification {
	|> key:identifier ([fixed - children]: sml* "," | sml* ")")
}

exp macro(props![- capture]) {
    | "logic_line!"
    | "line!"
    | "file!"
    | "directory!"
    | macro_pattern
    | macro_check_props
    | macro_file_content
}

exp macro_pattern {
	|> "pattern!"

	onback {
		log.error("Incorrect pattern! macro. The open parenthesis '(' is required.")
	}
	|> "(" sml* pattern? sml*

	onback {
		log.error("Incorrect pattern! macro. The close parenthesis ')' is required.")
	}
	|>  ")"
}

exp macro_check_props {
	|> "check_" object:property_style_object
}

exp macro_file_content {
	|> "file_content!"
    
    onback {
		log.error("Incorrect file_content! macro. A function call is required after the macro.")
	}
	|> function_call
}

#------------------------#
#-  Binary expressions  -#
#------------------------#

exp multiplicative_expression(props![- capture]) {
    for * do {
        |> values:prefix_expression
    }
    infix {
        |? ssl*
        |> operators:(operator[capture]: "//" | [*/%]) operator_end
        |? sml*
        set_props![capture]
    }
}

exp additive_expression(props![- capture]) {
    for * do {
        |> values:multiplicative_expression
    }
    infix {
        |? ssl*
        |> operators:(operator[capture]: [+-]) operator_end
        |? sml*
        set_props![capture]
    }
}

exp shift_expression(props![- capture]) {
    for * do {
        |> values:additive_expression
    }
    infix {
        |? ssl*
        |> operators:(operator[capture]: "<" [</] | [/>] ">") operator_end
        |? sml*
        set_props![capture]
    }
}

exp logic_expression(props![- capture]) {
    for * do {
        |> values:shift_expression
    }
    infix {
        |? ssl*
        |> operators:(operator[capture]: [&|^]) operator_end
        |? sml*
        set_props![capture]
    }
}

exp relational_expression(props![- capture]) {
    for * do {
        |> values:logic_expression
    }
    infix {
        |? ssl*
        |> operators:(operator[capture]: "==""="? | "!=""="? | "<""="? | ">""="?) operator_end
        |? sml*
        set_props![capture]
    }
}

exp conditional_expression(props![- capture]) {
    for * do {
        |> values:relational_expression
    }
    infix {
        |? ssl*
        |> operators:(operator[capture]: gen.keyword("and") | gen.keyword("or") | gen.keyword("xor"))
        |? sml*
        set_props![capture]
    }
}



#---------------#
#-  Operators  -#
#---------------#

exp prefix_operator {
    |> [-+~!]
}

exp assign_operator {
    |> operator[property]: {
        | "//"
        | "<" [</]
        | [/>] ">"
        | [*/%+-&|^]
        | gen.keyword("and")
        | gen.keyword("or")
        | gen.keyword("xor")
    }
    |> "=" operator_end
}



#------------#
#-  Others  -#
#------------#

exp operator_end(props![fixed - capture children]) {
    |> ![~!*/%+-&|^<>=]
}

