
#------------------------#
#- Lexem grammar v0.1.0 -#
#------------------------#
#- Description:
#-    Generic data and methods for the lexem's grammar.
#------------------------#

let {categories as ucd_categories} = import("lib:unicode")
let fn_exp = import("functional/expressions")



#----------------------#
#-  Generic Elements  -#
#----------------------#

let ucd_character = ucd_categories.Cn.reverse()



#-----------------#
#-  Whitespaces  -#
#-----------------#

pub! let whitespace_block = itv![\_ 0 1A 9 \(ucd_category.Zs)]
pub! exp whitespace(props![- capture backtrack]) {
	|> [\(whitespace_block)]
}
pub! let s = whitespace

pub! let whitespace_endOfLine_block = itv![D A 85 B C 2028 2029]
pub! exp whitespace_endOfLine(props![- backtrack]) {
	| "\u{D}\u{A}"
	| [\(whitespace_endOfLine_block)]
	| $$
}
pub! let eol = whitespace_endOfLine

pub! exp whitespace_singleline(props![- capture backtrack]) {
	| whitespace
	| comment_multiline
}
pub! let ssl = whitespace_singleline

pub! exp whitespace_multiline(props![- capture backtrack]) {
	| whitespace
	| comment
	| comment_multiline
	| whitespace_endOfLine
}
pub! let sml = whitespace_multiline

pub! let whitespace_logic_terminator = ";"
pub! exp whitespace_endOfLogicLine(props![- backtrack]) {
	|> (whitespace* | comment_multiline)*
	| "\(whitespace_logic_terminator)"
	| whitespace_endOfLine
	| comment
}
pub! let eoll = whitespace_endOfLogicLine


#--------------#
#-  Comments  -#
#--------------#

exp comment {
	|> "#-"
	|> (comment[property]: [\(ucd_character)]*?) whitespace_endOfLine
}

exp comment_multiline(props![capture - children]) {
	|> "#" (delimeter[property]: "+"+)
	onback {
		log.error("Incorrect multiline comment. The close symbol '\(node.properties.delimeter)#' was expected.")
	}
	|> comment[capture mark]: [!]*?
	|> "\(node.properties.delimeter)" "#"
}



#-----------------#
#-  identifiers  -#
#-----------------#

pub! exp identifier {
	|> [\(identifier_head_block)] [\(identifier_end_block)]*
}

let identifier_head_block = itv![61..7A 41..5A 5F A8 AA AD AF B2..B5 B7..BA BC..BE C0..D6 D8..F6 F8..FF 100..2FF 370..167F 
	1681..180D 180F..1DBF 1E00..1FFF 200B..200D 202A..202E 203F..2040 2054 2060..206F 2070..20CF 2100..218F 2460..24FF 2776..2793
	2C00..2DFF 2E80..2FFF 3004..3007 3021..302F 3031..303F 3040..D7FF F900..FD3D FD40..FDCF FDF0..FE1F FE30..FE44 FE47..FFFD]

let identifier_end_block = itv![30..39 300..36F 1DC0..1DFF 20D0..20FF FE20..FE2F \(identifier_head_block)]

pub! exp identifier_dynamic(props![- capture children]) {
	| escaped_expression
	| literal_any_string
	| identifier
}
	

#-------------#
#-  Escapes  -#
#-------------#

pub! exp escape(props![- capture]) {
	| escape_point
	| escaped_expression
	| escape_character
}

exp escape_character {
	|> "\\"
	onback {
		log.error("An escape requires a following character.")
	}
	|> character[property]: [!]
}


exp escape_point {
	| "\\u" set_props![isUnicode]
	| "\\p" set_props![-isUnicode]
	| {
		|> "{" s*
		onback {
			log.error("The \(if node.properties.isUnicode {"Unicode"} else {"Point"}) escape requires the value of the point.")
		}
		|> value:literal_integer_hexadecimal
		onback {
			log.error("The \(if node.properties.isUnicode {"Unicode"} else {"Point"}) escape requires the close bracket.")
		}
		|> s* "}"
	}
	| {
		onback {
			log.error("The \(if node.properties.isUnicode {"Unicode"} else {"Point"}) escape requires the value of the point.")
		}
		|> value:literal_integer_hexadecimal
	}
}

pub! exp escaped_expression {
	|> "\\{" sml*
	onback {
		log.error("The expression escape requires an expression as value.")
	}
	|> fn_exp.expression
	onback {
		log.error("The expression escape requires the close bracket.")
	}
	|> sml* "}"
}



#------------#
#-  Others  -#
#------------#

pub! exp check_keyword(keyword) {
	|> "\(keyword)" ![\(identifier_middle_block)]
}
    